---
name: ğŸ–¥ï¸  Deploy to EC2 with Ansible

on:
  # Manual trigger with options
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - destroy
        - maintenance
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      skip_infrastructure_setup:
        description: 'Skip infrastructure setup (security, monitoring)'
        required: false
        default: false
        type: boolean
  
  # Automatic triggers
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'package.json'
      - 'terraform-ec2/**'
      - 'ansible/**'
  
  pull_request:
    branches: [ main ]
    paths:
      - 'terraform-ec2/**'
      - 'ansible/**'

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.7.0
  ANSIBLE_VERSION: 8.0.0
  APP_NAME: kudos-app
  PYTHON_VERSION: '3.9'

jobs:
  # ============================================================================
  # INFRASTRUCTURE DEPLOYMENT JOB
  # ============================================================================
  infrastructure:
    name: ğŸ—ï¸  Infrastructure
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'maintenance'
    
    defaults:
      run:
        working-directory: terraform-ec2
    
    outputs:
      terraform_outputs: ${{ steps.terraform_outputs.outputs.result }}
      infrastructure_created: ${{ steps.apply.outcome == 'success' }}
    
    steps:
      # Checkout code
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4
      
      # Configure AWS credentials
      - name: âš™ï¸  Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      # Setup Terraform
      - name: ğŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      
      # Initialize Terraform
      - name: ğŸš€ Initialize Terraform
        run: terraform init
      
      # Validate Terraform configuration
      - name: âœ… Validate Terraform
        run: terraform validate
      
      # Format check (for PRs)
      - name: ğŸ“ Terraform Format Check
        if: github.event_name == 'pull_request'
        run: terraform fmt -check -recursive
      
      # Plan infrastructure changes
      - name: ğŸ“‹ Plan Infrastructure
        id: plan
        run: |
          terraform plan -input=false -out=tfplan \
            -var="environment=${{ github.event.inputs.environment || 'dev' }}"
          
          # Save plan output for PR comments
          terraform show -no-color tfplan > plan_output.txt
        continue-on-error: true
      
      # Comment PR with plan
      - name: ğŸ’¬ Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('terraform-ec2/plan_output.txt', 'utf8');
            const truncatedPlan = plan.length > 60000 ? plan.substring(0, 60000) + '\n... (truncated)' : plan;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ğŸ—ï¸ Terraform Plan
              
              <details>
              <summary>Click to view plan details</summary>
              
              \`\`\`
              ${truncatedPlan}
              \`\`\`
              
              </details>
              
              **Environment:** ${{ github.event.inputs.environment || 'dev' }}
              **Action:** Plan completed ${steps.plan.outcome === 'success' ? 'âœ…' : 'âŒ'}`
            });
      
      # Apply infrastructure changes (only on manual deploy or push to main)
      - name: ğŸš€ Apply Infrastructure
        id: apply
        if: |
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'deploy') ||
          (github.event_name == 'push' && github.ref == 'refs/heads/main')
        run: terraform apply -auto-approve tfplan
      
      # Destroy infrastructure (only on manual destroy)
      - name: ğŸ—‘ï¸  Destroy Infrastructure
        id: destroy
        if: github.event.inputs.action == 'destroy'
        run: |
          terraform destroy -auto-approve \
            -var="environment=${{ github.event.inputs.environment || 'dev' }}"
      
      # Save Terraform outputs
      - name: ğŸ“Š Save Terraform Outputs
        id: terraform_outputs
        if: steps.apply.outcome == 'success'
        run: |
          terraform output -json > outputs.json
          echo "result=$(cat outputs.json | jq -c .)" >> $GITHUB_OUTPUT
      
      # Upload Terraform state and outputs
      - name: ğŸ“¤ Upload Terraform Artifacts
        if: always() && (steps.apply.outcome == 'success' || steps.destroy.outcome == 'success')
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state-${{ github.run_number }}
          path: |
            terraform-ec2/terraform.tfstate
            terraform-ec2/outputs.json
            terraform-ec2/*.pem
          retention-days: 7

  # ============================================================================
  # ANSIBLE DEPLOYMENT JOB
  # ============================================================================
  ansible-deployment:
    name: ğŸš€ Ansible Deployment
    runs-on: ubuntu-latest
    needs: infrastructure
    if: |
      always() && 
      (needs.infrastructure.outputs.infrastructure_created == 'true' || 
       github.event.inputs.action == 'maintenance')
    
    defaults:
      run:
        working-directory: ansible
    
    steps:
      # Checkout code
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4
      
      # Setup Python
      - name: ğŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      # Configure AWS credentials
      - name: âš™ï¸  Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      # Download Terraform artifacts (if infrastructure was created)
      - name: ğŸ“¥ Download Terraform Artifacts
        if: needs.infrastructure.outputs.infrastructure_created == 'true'
        uses: actions/download-artifact@v4
        with:
          name: terraform-state-${{ github.run_number }}
          path: terraform-ec2/
      
      # Install Ansible and dependencies
      - name: ğŸ“¦ Install Ansible
        run: |
          pip install ansible==${{ env.ANSIBLE_VERSION }} boto3 botocore
          
          # Install required Ansible collections
          ansible-galaxy collection install amazon.aws
          ansible-galaxy collection install community.general
      
      # Setup SSH key permissions
      - name: ğŸ”‘ Setup SSH Key
        if: needs.infrastructure.outputs.infrastructure_created == 'true'
        run: |
          if [ -f ../terraform-ec2/kudos-app-dev-key.pem ]; then
            chmod 600 ../terraform-ec2/kudos-app-dev-key.pem
            echo "SSH key permissions set"
          else
            echo "SSH key not found - using existing infrastructure"
          fi
      
      # Test Ansible connectivity
      - name: ğŸ”Œ Test Ansible Connectivity
        id: connectivity
        run: |
          # Wait for instances to be ready
          echo "Waiting for instances to be ready..."
          sleep 60
          
          # Test connectivity with retries
          max_attempts=5
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Connectivity test attempt $attempt/$max_attempts..."
            
            if ansible webservers -m ping -i inventory/aws_ec2.yml; then
              echo "connectivity=success" >> $GITHUB_OUTPUT
              echo "âœ… Ansible connectivity established"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                echo "â³ Retrying in 30 seconds..."
                sleep 30
              else
                echo "connectivity=failed" >> $GITHUB_OUTPUT
                echo "âŒ Failed to establish connectivity"
                exit 1
              fi
            fi
            
            ((attempt++))
          done
      
      # Infrastructure Setup
      - name: ğŸ› ï¸  Setup Infrastructure
        if: |
          steps.connectivity.outputs.connectivity == 'success' && 
          !github.event.inputs.skip_infrastructure_setup &&
          github.event.inputs.action != 'maintenance'
        run: |
          ansible-playbook playbooks/setup-infrastructure.yml \
            -i inventory/aws_ec2.yml \
            -v
      
      # Deploy Application
      - name: ğŸš€ Deploy Application
        if: |
          steps.connectivity.outputs.connectivity == 'success' &&
          github.event.inputs.action != 'maintenance'
        run: |
          # Update repository URL in playbook
          sed -i 's|https://github.com/YOUR_USERNAME/kudos-app.git|${{ github.server_url }}/${{ github.repository }}.git|g' \
            playbooks/deploy-app.yml
          
          ansible-playbook playbooks/deploy-app.yml \
            -i inventory/aws_ec2.yml \
            -v
      
      # Run Maintenance
      - name: ğŸ”§ Run Maintenance
        if: |
          steps.connectivity.outputs.connectivity == 'success' &&
          (github.event.inputs.action == 'maintenance' || github.event.inputs.action == 'deploy')
        run: |
          ansible-playbook playbooks/maintenance.yml \
            -i inventory/aws_ec2.yml \
            -v
      
      # Upload Ansible logs
      - name: ğŸ“¤ Upload Ansible Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ansible-logs-${{ github.run_number }}
          path: |
            ansible/logs/
            ansible/*.log
          retention-days: 7

  # ============================================================================
  # VERIFICATION AND REPORTING JOB
  # ============================================================================
  verification:
    name: âœ… Verification
    runs-on: ubuntu-latest
    needs: [infrastructure, ansible-deployment]
    if: |
      always() && 
      needs.infrastructure.result != 'failure' &&
      needs.ansible-deployment.result != 'failure' &&
      github.event.inputs.action != 'destroy' &&
      github.event.inputs.action != 'maintenance'
    
    steps:
      # Checkout code
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4
      
      # Configure AWS credentials
      - name: âš™ï¸  Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      # Download Terraform artifacts
      - name: ğŸ“¥ Download Terraform Artifacts
        uses: actions/download-artifact@v4
        with:
          name: terraform-state-${{ github.run_number }}
          path: terraform-ec2/
      
      # Get application URL
      - name: ğŸŒ Get Application URL
        id: get_url
        run: |
          cd terraform-ec2
          
          # Setup Terraform
          curl -fsSL https://releases.hashicorp.com/terraform/${{ env.TF_VERSION }}/terraform_${{ env.TF_VERSION }}_linux_amd64.zip -o terraform.zip
          unzip terraform.zip
          chmod +x terraform
          
          # Initialize and get outputs
          ./terraform init -input=false
          APP_URL=$(./terraform output -raw application_url)
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "Application URL: $APP_URL"
      
      # Health Check
      - name: ğŸ¥ Health Check
        id: health_check
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          
          echo "Testing application health at: $APP_URL"
          
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Health check attempt $attempt/$max_attempts..."
            
            http_code=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL" || echo "000")
            
            if [ "$http_code" = "200" ]; then
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              echo "âœ… Application is healthy (HTTP $http_code)"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                echo "â³ Waiting 30 seconds before retry..."
                sleep 30
              else
                echo "health_status=unhealthy" >> $GITHUB_OUTPUT
                echo "âŒ Application health check failed (HTTP $http_code)"
              fi
            fi
            
            ((attempt++))
          done
      
      # Get instance information
      - name: ğŸ–¥ï¸  Get Instance Information
        id: instance_info
        run: |
          echo "## Instance Information" >> deployment_summary.md
          echo "" >> deployment_summary.md
          
          aws ec2 describe-instances \
            --filters "Name=tag:Project,Values=${{ env.APP_NAME }}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].[Tags[?Key==`Name`].Value|[0],InstanceId,PublicIpAddress,InstanceType,State.Name]' \
            --output table >> deployment_summary.md

  # ============================================================================
  # CREATE DEPLOYMENT ISSUE
  # ============================================================================
  create-issue:
    name: ğŸ“ Create Issue
    runs-on: ubuntu-latest
    needs: [infrastructure, ansible-deployment, verification]
    if: |
      always() && 
      github.event.inputs.action == 'deploy'
    
    permissions:
      issues: write
    
    steps:
      # Create deployment summary issue
      - name: ğŸ“ Create Deployment Summary Issue
        uses: actions/github-script@v7
        with:
          script: |
            const infraResult = '${{ needs.infrastructure.result }}';
            const ansibleResult = '${{ needs.ansible-deployment.result }}';
            const verificationResult = '${{ needs.verification.result }}';
            const appUrl = '${{ needs.verification.outputs.app_url || 'N/A' }}';
            const healthStatus = '${{ needs.verification.outputs.health_status || 'unknown' }}';
            
            const status = (infraResult === 'success' && ansibleResult === 'success') ? 'âœ… SUCCESS' : 'âŒ FAILED';
            const environment = '${{ github.event.inputs.environment || 'dev' }}';
            
            const issueBody = `
            # ğŸ–¥ï¸ EC2 + Ansible Deployment Report
            
            **Status:** ${status}
            **Environment:** ${environment}
            **Deployment Time:** ${new Date().toISOString()}
            **Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            
            ## ğŸ“Š Results Summary
            
            | Component | Status | Result |
            |-----------|--------|---------|
            | ğŸ—ï¸ Infrastructure | ${infraResult === 'success' ? 'âœ…' : 'âŒ'} | ${infraResult} |
            | ğŸš€ Ansible Deployment | ${ansibleResult === 'success' ? 'âœ…' : 'âŒ'} | ${ansibleResult} |
            | âœ… Verification | ${verificationResult === 'success' ? 'âœ…' : 'âŒ'} | ${verificationResult} |
            | ğŸ¥ Health Check | ${healthStatus === 'healthy' ? 'âœ…' : 'âŒ'} | ${healthStatus} |
            
            ## ğŸŒ Access Information
            
            **Application URL:** ${appUrl}
            
            ## ğŸ”§ Management Commands
            
            \`\`\`bash
            # Connect to instances
            aws ec2 describe-instances --filters "Name=tag:Project,Values=${{ env.APP_NAME }}"
            
            # Run Ansible maintenance
            cd ansible && ansible-playbook playbooks/maintenance.yml -i inventory/aws_ec2.yml
            
            # Check application status
            cd ansible && ansible webservers -m shell -a "sudo -u ec2-user pm2 status" -i inventory/aws_ec2.yml
            
            # Destroy infrastructure
            cd terraform-ec2 && terraform destroy
            \`\`\`
            
            ## ğŸ“‹ Next Steps
            
            ${status.includes('SUCCESS') ? 
              '- âœ… Deployment successful! Application is running\n- ğŸŒ Access your app at the URL above\n- ğŸ“Š Monitor with the maintenance playbook\n- ğŸ”„ Update by pushing to main branch' :
              '- âŒ Deployment failed - check workflow logs\n- ğŸ” Review the failed steps above\n- ğŸ”„ Fix issues and re-run workflow\n- ğŸ’¡ Check AWS console for resource status'
            }
            
            ---
            *Automated deployment by GitHub Actions*
            `;
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸ–¥ï¸ EC2 Deployment ${status} - ${environment} (${new Date().toLocaleDateString()})`,
              body: issueBody,
              labels: [
                'deployment', 
                'ec2', 
                'ansible',
                status.includes('SUCCESS') ? 'success' : 'failure',
                environment
              ]
            });
            
            console.log(`Created issue #${issue.data.number}`);

  # ============================================================================
  # SLACK NOTIFICATION (OPTIONAL)
  # ============================================================================
  notify:
    name: ğŸ“¢ Notify
    runs-on: ubuntu-latest
    needs: [infrastructure, ansible-deployment, verification]
    if: always() && github.event_name != 'pull_request'
    
    steps:
      # Send Slack notification
      - name: ğŸ“¢ Send Slack Notification
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          status="${{ (needs.infrastructure.result == 'success' && needs.ansible-deployment.result == 'success') && 'âœ… SUCCESS' || 'âŒ FAILED' }}"
          app_url="${{ needs.verification.outputs.app_url || 'N/A' }}"
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\":\"ğŸ–¥ï¸ EC2 + Ansible Deployment ${status}\",
              \"blocks\":[
                {
                  \"type\":\"section\",
                  \"text\":{
                    \"type\":\"mrkdwn\",
                    \"text\":\"*ğŸ–¥ï¸ EC2 + Ansible Deployment Report*\n*Status:* ${status}\n*Environment:* ${{ github.event.inputs.environment || 'dev' }}\n*Application URL:* ${app_url}\"
                  }
                },
                {
                  \"type\":\"actions\",
                  \"elements\":[
                    {
                      \"type\":\"button\",
                      \"text\":{\"type\":\"plain_text\",\"text\":\"View Workflow\"},
                      \"url\":\"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                    }
                  ]
                }
              ]
            }" \
            $SLACK_WEBHOOK_URL