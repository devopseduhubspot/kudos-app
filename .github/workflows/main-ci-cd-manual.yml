# =========================================================
# CI/CD Pipeline with AWS EKS Deployment
# =========================================================

name: main-ci-cd-manual

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      mode:
        description: 'Pipeline Mode'
        required: true
        default: 'full-pipeline'
        type: choice
        options:
          - full-pipeline
          - docker-only
          - build-only

# ---------------------------------------------------------
# Environment Variables
# ---------------------------------------------------------
env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: kudos-app-cluster
  ECR_REPOSITORY: kudos-app-${{ github.event.inputs.environment || 'dev' }}
  IMAGE_TAG: ${{ github.sha }}
  BRANCH_NAME: ${{ github.ref_name }}
  BUILD_DATETIME: ${{ github.run_id }}-$(date +'%Y%m%d-%H%M%S')

# ---------------------------------------------------------
# 1. Install Dependencies
# ---------------------------------------------------------
jobs:
  install:
    name: "ğŸ“¦ Install Dependencies"
    runs-on: ubuntu-latest
    if: github.event.inputs.mode != 'docker-only'
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm

      - run: npm ci

# ---------------------------------------------------------
# 2. Lint
# ---------------------------------------------------------
  lint:
    name: "ğŸ” Lint"
    runs-on: ubuntu-latest
    needs: install
    if: github.event.inputs.mode != 'docker-only'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm
      - run: npm ci
      - run: npm run lint

# ---------------------------------------------------------
# 3. Test
# ---------------------------------------------------------
  test:
    name: "ğŸ§ª Test"
    runs-on: ubuntu-latest
    needs: lint
    if: github.event.inputs.mode != 'docker-only'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm
      - run: npm ci
      - run: npm run test:ci

# ---------------------------------------------------------
# 4. Security Scan
# ---------------------------------------------------------
  security-scan:
    name: "ğŸ›¡ï¸ Security Scan"
    runs-on: ubuntu-latest
    needs: lint

    steps:
      - name: "ğŸ” Checkout"
        uses: actions/checkout@v4

      - name: "ğŸ” Validate SNYK_TOKEN"
        run: |
          if [ -z "$SNYK_TOKEN" ]; then
            echo "âŒ SNYK_TOKEN secret is missing"
            exit 1
          fi
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: "ğŸ” Snyk Test (Fail on vulnerabilities)"
        uses: snyk/actions/node@v1
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: test

      - name: "ğŸ“Š Snyk Monitor (Send report to dashboard)"
        if: always()
        uses: snyk/actions/node@v1
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: monitor

# ---------------------------------------------------------
# 5. Build
# ---------------------------------------------------------
  build:
    name: "ğŸ—ï¸ Build"
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.event.inputs.mode == 'full-pipeline'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm
      - run: npm ci
      - run: npm run build

# ---------------------------------------------------------
# 6. Build & Push to ECR
# ---------------------------------------------------------
  docker:
    name: "ğŸ³ Build & Push to ECR"
    runs-on: ubuntu-latest
    needs: build
    if: always() && (needs.build.result == 'success' || github.event.inputs.mode == 'docker-only')
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      branch-datetime-tag: ${{ steps.build-image.outputs.branch-datetime-tag }}
    steps:
      - name: "ğŸ” Checkout"
        uses: actions/checkout@v4

      - name: "ğŸ”‘ Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "ğŸ“¦ Create ECR Repository (if not exists)"
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION

      - name: "ğŸ—ï¸ Login to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: "ğŸ³ Build, tag, and push image to Amazon ECR"
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Generate datetime tag
          DATETIME_TAG=$(date +'%Y%m%d-%H%M%S')
          BRANCH_CLEAN=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Build and tag with multiple tags
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:${BRANCH_CLEAN}-${DATETIME_TAG} .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:${BRANCH_CLEAN}-latest .
          
          # Push all tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:${BRANCH_CLEAN}-${DATETIME_TAG}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:${BRANCH_CLEAN}-latest
          
          # Output the main image reference
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "branch-datetime-tag=${BRANCH_CLEAN}-${DATETIME_TAG}" >> $GITHUB_OUTPUT
          
          # Display pushed tags
          echo "ğŸ“¦ Pushed Docker images with tags:"
          echo "  â€¢ $IMAGE_TAG (commit SHA)"
          echo "  â€¢ latest (always latest)"
          echo "  â€¢ ${BRANCH_CLEAN}-${DATETIME_TAG} (branch + datetime)"
          echo "  â€¢ ${BRANCH_CLEAN}-latest (branch latest)"

      - name: "ğŸ” Scan image for vulnerabilities"
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build-image.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: "ğŸ“‹ Check Trivy results"
        run: |
          if [ -f "trivy-results.sarif" ]; then
            echo "âœ… Trivy scan completed successfully"
            echo "ğŸ“Š SARIF file size: $(wc -c < trivy-results.sarif) bytes"
          else
            echo "âš ï¸  Trivy results file not found, creating empty SARIF"
            echo '{"version":"2.1.0","runs":[]}' > trivy-results.sarif
          fi

      - name: "ğŸ“Š Upload Trivy scan results"
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: 'trivy-results.sarif'

# ---------------------------------------------------------
# 7. Deploy to AWS EKS
# ---------------------------------------------------------
  deploy-eks:
    name: "â˜¸ï¸ Deploy to AWS EKS"
    runs-on: ubuntu-latest
    needs: docker
    if: github.event.inputs.mode != 'build-only'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: "ğŸ” Checkout"
        uses: actions/checkout@v4

      - name: "ğŸ”‘ Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "âš™ï¸ Setup kubectl"
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: "ğŸ”— Update kubeconfig for EKS"
        run: |
          aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
          kubectl cluster-info

      - name: "ğŸ—ï¸ Update Kubernetes manifests with new image"
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
        run: |
          # Update the image in deployment.yaml
          sed -i "s|image:.*|image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG|" k8s/deployment.yaml
          
          # Show what we're deploying
          echo "ğŸ” Updated Kubernetes manifests:"
          grep -n "image:" k8s/deployment.yaml

      - name: "ğŸš€ Deploy to EKS"
        run: |
          echo "ğŸš€ Deploying to EKS cluster: $EKS_CLUSTER_NAME"
          kubectl apply -k k8s/
          
          # Add labels for tracking
          kubectl label deployment/kudos-frontend version=$IMAGE_TAG --overwrite
          kubectl label deployment/kudos-frontend environment=${{ github.event.inputs.environment || 'dev' }} --overwrite

      - name: "â³ Wait for Deployment Rollout"
        run: |
          echo "â³ Waiting for deployment to complete..."
          kubectl rollout status deployment/kudos-frontend --timeout=300s

      - name: "ğŸ” Verify Deployment"
        run: |
          echo "ğŸ” Checking deployment status..."
          kubectl get deployments
          kubectl get pods -l app=kudos-frontend
          kubectl get services

      # ---- HEALTH CHECK VALIDATION ----
      - name: "ğŸ¥ Application Health Check"
        run: |
          echo "ğŸ¥ Running application health checks..."
          
          # Get pod details
          POD=$(kubectl get pods -l app=kudos-frontend -o jsonpath='{.items[0].metadata.name}')
          echo "Testing pod: $POD"
          
          # Check if nginx is running
          kubectl exec $POD -- ps aux | grep nginx || {
            echo "âŒ Nginx process not found"
            kubectl logs $POD
            exit 1
          }
          
          # Check if the service is accessible
          kubectl port-forward svc/kudos-frontend 8080:80 &
          PF_PID=$!
          sleep 10
          
          # Test HTTP endpoint
          for i in {1..5}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 || echo "000")
            if [ "$STATUS" = "200" ]; then
              echo "âœ… Health check passed (HTTP 200)"
              kill $PF_PID 2>/dev/null || true
              exit 0
            fi
            echo "â³ Attempt $i: HTTP $STATUS, retrying..."
            sleep 5
          done
          
          echo "âŒ Health check failed after 5 attempts"
          kill $PF_PID 2>/dev/null || true
          kubectl logs $POD
          exit 1

      - name: "ğŸ“Š Deployment Summary"
        if: always()
        run: |
          echo "ğŸ“Š === DEPLOYMENT SUMMARY ==="
          echo "ğŸ”– Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "ï¿½ Branch: ${{ github.ref_name }}"
          echo "ğŸ·ï¸  Image Tag: $IMAGE_TAG"
          echo "ğŸ“… Branch-DateTime Tag: ${{ steps.build-image.outputs.branch-datetime-tag || 'N/A' }}"
          echo "ğŸ¯ EKS Cluster: $EKS_CLUSTER_NAME"
          echo "ğŸŒ AWS Region: $AWS_REGION"
          echo ""
          echo "ğŸ“‹ Final Status:"
          kubectl get deployment/kudos-frontend -o wide
          echo ""
          echo "ğŸ”— Service Details:"
          kubectl get service/kudos-frontend -o wide

# ---------------------------------------------------------
# 8. Post-Deployment Validation & Notifications
# ---------------------------------------------------------
  post-deployment:
    name: "ğŸ“‹ Post-Deployment Validation"
    runs-on: ubuntu-latest
    needs: deploy-eks
    if: always()

    steps:
      - name: "ğŸ”‘ Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "âš™ï¸ Setup kubectl"
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: "ğŸ”— Update kubeconfig for EKS"
        run: aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME

      - name: "ğŸ“Š Generate Deployment Report"
        run: |
          echo "# ğŸ“Š Deployment Report" > deployment-report.md
          echo "" >> deployment-report.md
          echo "**Environment:** ${{ github.event.inputs.environment || 'dev' }}" >> deployment-report.md
          echo "**Branch:** ${{ github.ref_name }}" >> deployment-report.md
          echo "**Image Tag:** $IMAGE_TAG" >> deployment-report.md
          echo "**Branch-DateTime Tag:** ${{ needs.docker.outputs.branch-datetime-tag || 'N/A' }}" >> deployment-report.md
          echo "**Deployment Time:** $(date -u)" >> deployment-report.md
          echo "**Commit SHA:** ${{ github.sha }}" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## Application Status" >> deployment-report.md
          echo '```' >> deployment-report.md
          kubectl get deployment/kudos-frontend -o wide >> deployment-report.md
          echo '```' >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## Pods Status" >> deployment-report.md
          echo '```' >> deployment-report.md
          kubectl get pods -l app=kudos-frontend >> deployment-report.md
          echo '```' >> deployment-report.md

      - name: "ğŸ“§ Deployment Success Notification"
        if: needs.deploy-eks.result == 'success'
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸ¯ Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "ğŸ·ï¸  Image: $IMAGE_TAG"

      - name: "ğŸš¨ Deployment Failure Notification"
        if: needs.deploy-eks.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "ğŸ” Check the logs above for details"
          kubectl get events --sort-by='.lastTimestamp' || true
