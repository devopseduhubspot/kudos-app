# =========================================================
# CI/CD Pipeline with AWS EKS Deployment
# =========================================================

name: main-ci-cd-manual

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      mode:
        description: 'Pipeline Mode'
        required: true
        default: 'full-pipeline'
        type: choice
        options:
          - full-pipeline
          - docker-only
          - build-only

# ---------------------------------------------------------
# Environment Variables
# ---------------------------------------------------------
env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: kudos-app-${{ github.event.inputs.environment || 'dev' }}
  ECR_REPOSITORY_FRONTEND: kudos-app-${{ github.event.inputs.environment || 'dev' }}
  ECR_REPOSITORY_BACKEND: kudos-app-backend-${{ github.event.inputs.environment || 'dev' }}
  IMAGE_TAG: ${{ github.sha }}
  BRANCH_NAME: ${{ github.ref_name }}
  BUILD_DATETIME: ${{ github.run_id }}-$(date +'%Y%m%d-%H%M%S')

# ---------------------------------------------------------
# 1. Install Dependencies
# ---------------------------------------------------------
jobs:
  install:
    name: "ğŸ“¦ Install Dependencies"
    runs-on: ubuntu-latest
    if: github.event.inputs.mode != 'docker-only'
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm

      - run: npm ci

# ---------------------------------------------------------
# 2. Lint
# ---------------------------------------------------------
  lint:
    name: "ğŸ” Lint"
    runs-on: ubuntu-latest
    needs: install
    if: github.event.inputs.mode != 'docker-only'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm
      - run: npm ci
      - run: npm run lint

# ---------------------------------------------------------
# 3. Test
# ---------------------------------------------------------
  test:
    name: "ğŸ§ª Test"
    runs-on: ubuntu-latest
    needs: lint
    if: github.event.inputs.mode != 'docker-only'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm
      - run: npm ci
      - run: npm run test:ci

# ---------------------------------------------------------
# 4. Security Scan
# ---------------------------------------------------------
  security-scan:
    name: "ğŸ›¡ï¸ Security Scan"
    runs-on: ubuntu-latest
    needs: lint

    steps:
      - name: "ğŸ” Checkout"
        uses: actions/checkout@v4

      - name: "ğŸ” Validate SNYK_TOKEN"
        run: |
          if [ -z "$SNYK_TOKEN" ]; then
            echo "âŒ SNYK_TOKEN secret is missing"
            exit 1
          fi
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: "ğŸ” Snyk Test (Fail on vulnerabilities)"
        uses: snyk/actions/node@v1
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: test

      - name: "ğŸ“Š Snyk Monitor (Send report to dashboard)"
        if: always()
        uses: snyk/actions/node@v1
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: monitor

# ---------------------------------------------------------
# 5. Build
# ---------------------------------------------------------
  build:
    name: "ğŸ—ï¸ Build"
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.event.inputs.mode == 'full-pipeline'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: npm
      - run: npm ci
      - run: npm run build

# ---------------------------------------------------------
# 6. Build & Push to ECR (Frontend & Backend)
# ---------------------------------------------------------
  docker:
    name: "ğŸ³ Build & Push to ECR"
    runs-on: ubuntu-latest
    needs: build
    if: always() && (needs.build.result == 'success' || github.event.inputs.mode == 'docker-only')
    outputs:
      frontend-image-uri: ${{ steps.build-frontend.outputs.image }}
      backend-image-uri: ${{ steps.build-backend.outputs.image }}
      branch-datetime-tag: ${{ steps.build-frontend.outputs.branch-datetime-tag }}
    steps:
      - name: "ğŸ” Checkout"
        uses: actions/checkout@v4

      - name: "ğŸ”‘ Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "ğŸ“¦ Create ECR Repositories (if not exists)"
        run: |
          # Create frontend repository
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_FRONTEND --region $AWS_REGION || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY_FRONTEND --region $AWS_REGION
          
          # Create backend repository
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_BACKEND --region $AWS_REGION || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY_BACKEND --region $AWS_REGION

      - name: "ğŸ—ï¸ Login to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: "ğŸ³ Build, tag, and push Frontend image to Amazon ECR"
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Generate datetime tag
          DATETIME_TAG=$(date +'%Y%m%d-%H%M%S')
          BRANCH_CLEAN=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Build and tag with multiple tags
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${BRANCH_CLEAN}-${DATETIME_TAG} .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${BRANCH_CLEAN}-latest .
          
          # Push all tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${BRANCH_CLEAN}-${DATETIME_TAG}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${BRANCH_CLEAN}-latest
          
          # Output the main image reference
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "branch-datetime-tag=${BRANCH_CLEAN}-${DATETIME_TAG}" >> $GITHUB_OUTPUT

      - name: "ğŸ³ Build, tag, and push Backend image to Amazon ECR"
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Generate datetime tag
          DATETIME_TAG=$(date +'%Y%m%d-%H%M%S')
          BRANCH_CLEAN=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Build and tag with multiple tags using backend Dockerfile
          docker build -f Dockerfile.backend -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG .
          docker build -f Dockerfile.backend -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest .
          docker build -f Dockerfile.backend -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${BRANCH_CLEAN}-${DATETIME_TAG} .
          docker build -f Dockerfile.backend -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${BRANCH_CLEAN}-latest .
          
          # Push all tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${BRANCH_CLEAN}-${DATETIME_TAG}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${BRANCH_CLEAN}-latest
          
          # Output the main image reference
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          # Display pushed tags
          echo "ğŸ“¦ Pushed Docker images with tags:"
          echo "Frontend:"
          echo "  â€¢ $IMAGE_TAG (commit SHA)"
          echo "  â€¢ latest (always latest)"
          echo "  â€¢ ${BRANCH_CLEAN}-${DATETIME_TAG} (branch + datetime)"
          echo "  â€¢ ${BRANCH_CLEAN}-latest (branch latest)"
          echo "Backend:"
          echo "  â€¢ $IMAGE_TAG (commit SHA)"
          echo "  â€¢ latest (always latest)"
          echo "  â€¢ ${BRANCH_CLEAN}-${DATETIME_TAG} (branch + datetime)"
          echo "  â€¢ ${BRANCH_CLEAN}-latest (branch latest)"

      - name: "ğŸ” Scan Frontend image for vulnerabilities"
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build-frontend.outputs.image }}
          format: 'sarif'
          output: 'trivy-frontend-results.sarif'
        continue-on-error: true

      - name: "ğŸ” Scan Backend image for vulnerabilities"
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build-backend.outputs.image }}
          format: 'sarif'
          output: 'trivy-backend-results.sarif'
        continue-on-error: true

      - name: "ğŸ“‹ Check Trivy results"
        run: |
          for file in trivy-frontend-results.sarif trivy-backend-results.sarif; do
            if [ -f "$file" ]; then
              echo "âœ… $file scan completed successfully"
              echo "ğŸ“Š SARIF file size: $(wc -c < $file) bytes"
            else
              echo "âš ï¸  $file not found, creating empty SARIF"
              echo '{"version":"2.1.0","runs":[]}' > $file
            fi
          done

      - name: "ğŸ“Š Upload Frontend Trivy scan results"
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-frontend-results.sarif') != ''
        with:
          sarif_file: 'trivy-frontend-results.sarif'
          category: 'frontend'

      - name: "ğŸ“Š Upload Backend Trivy scan results"  
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-backend-results.sarif') != ''
        with:
          sarif_file: 'trivy-backend-results.sarif'
          category: 'backend'

# ---------------------------------------------------------
# 7. Deploy to AWS EKS
# ---------------------------------------------------------
  deploy-eks:
    name: "â˜¸ï¸ Deploy to AWS EKS"
    runs-on: ubuntu-latest
    needs: docker
    if: github.event.inputs.mode != 'build-only'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: "ğŸ” Checkout"
        uses: actions/checkout@v4

      - name: "ğŸ”‘ Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "âš™ï¸ Setup kubectl"
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: "ğŸ”— Update kubeconfig for EKS"
        run: |
          echo "ğŸ” Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "ğŸ¯ Looking for EKS cluster: $EKS_CLUSTER_NAME"
          echo "ğŸŒ In region: $AWS_REGION"
          aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
          kubectl cluster-info

      - name: "ğŸ—ï¸ Update Kubernetes manifests with new images"
        run: |
          # Get ECR registry dynamically
          ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com
          FRONTEND_IMAGE_NAME=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
          BACKEND_IMAGE_NAME=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
          
          echo "ğŸ” Using images:"
          echo "Frontend: $FRONTEND_IMAGE_NAME"
          echo "Backend: $BACKEND_IMAGE_NAME"
          
          # Update both images in deployment.yaml
          sed -i "/kudos-frontend/{N;N;N;s|image:.*|image: $FRONTEND_IMAGE_NAME|}" k8s/deployment.yaml
          sed -i "/kudos-backend/{N;N;N;s|image:.*|image: $BACKEND_IMAGE_NAME|}" k8s/deployment.yaml
          
          # Show what we're deploying
          echo "ğŸ” Updated Kubernetes manifests:"
          grep -n "image:" k8s/deployment.yaml

      - name: "ğŸš€ Deploy to EKS"
        run: |
          echo "ğŸš€ Deploying to EKS cluster: $EKS_CLUSTER_NAME"
          kubectl apply -k k8s/
          
          # Add labels for tracking
          kubectl label deployment/kudos-frontend version=$IMAGE_TAG --overwrite
          kubectl label deployment/kudos-frontend environment=${{ github.event.inputs.environment || 'dev' }} --overwrite
          kubectl label deployment/kudos-backend version=$IMAGE_TAG --overwrite
          kubectl label deployment/kudos-backend environment=${{ github.event.inputs.environment || 'dev' }} --overwrite

      - name: "â³ Wait for Deployment Rollout"
        run: |
          echo "â³ Waiting for deployments to complete..."
          kubectl rollout status deployment/kudos-frontend --timeout=300s
          kubectl rollout status deployment/kudos-backend --timeout=300s

      - name: "ğŸ” Verify Deployment"
        run: |
          echo "ğŸ” Checking deployment status..."
          kubectl get deployments
          kubectl get pods -l app=kudos-frontend
          kubectl get pods -l app=kudos-backend
          kubectl get services

      # ---- HEALTH CHECK VALIDATION ----
      - name: "ğŸ¥ Application Health Check"
        run: |
          echo "ğŸ¥ Running application health checks..."
          
          # Check Backend Health First
          echo "ğŸ” Testing Backend Health..."
          BACKEND_POD=$(kubectl get pods -l app=kudos-backend -o jsonpath='{.items[0].metadata.name}')
          echo "Backend pod: $BACKEND_POD"
          
          # Port forward backend service for health check
          kubectl port-forward svc/kudos-backend 3001:3001 &
          BACKEND_PF_PID=$!
          sleep 10
          
          # Test backend health endpoint
          for i in {1..5}; do
            BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health || echo "000")
            if [ "$BACKEND_STATUS" = "200" ]; then
              echo "âœ… Backend health check passed (HTTP 200)"
              break
            fi
            echo "â³ Backend attempt $i: HTTP $BACKEND_STATUS, retrying..."
            sleep 5
          done
          
          kill $BACKEND_PF_PID 2>/dev/null || true
          
          if [ "$BACKEND_STATUS" != "200" ]; then
            echo "âŒ Backend health check failed"
            kubectl logs $BACKEND_POD
            exit 1
          fi
          
          # Check Frontend Health
          echo "ğŸ” Testing Frontend Health..."
          FRONTEND_POD=$(kubectl get pods -l app=kudos-frontend -o jsonpath='{.items[0].metadata.name}')
          echo "Frontend pod: $FRONTEND_POD"
          
          # Check if nginx is running
          kubectl exec $FRONTEND_POD -- ps aux | grep nginx || {
            echo "âŒ Nginx process not found"
            kubectl logs $FRONTEND_POD
            exit 1
          }
          
          # Check if the frontend service is accessible
          kubectl port-forward svc/kudos-frontend 8080:80 &
          FRONTEND_PF_PID=$!
          sleep 10
          
          # Test HTTP endpoint
          for i in {1..5}; do
            FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 || echo "000")
            if [ "$FRONTEND_STATUS" = "200" ]; then
              echo "âœ… Frontend health check passed (HTTP 200)"
              kill $FRONTEND_PF_PID 2>/dev/null || true
              exit 0
            fi
            echo "â³ Frontend attempt $i: HTTP $FRONTEND_STATUS, retrying..."
            sleep 5
          done
          
          echo "âŒ Frontend health check failed after 5 attempts"
          kill $FRONTEND_PF_PID 2>/dev/null || true
          kubectl logs $FRONTEND_POD
          exit 1

      - name: "ğŸ“Š Deployment Summary"
        if: always()
        run: |
          echo "ğŸ“Š === DEPLOYMENT SUMMARY ==="
          echo "ğŸ”– Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "ï¿½ Branch: ${{ github.ref_name }}"
          echo "ğŸ·ï¸  Image Tag: $IMAGE_TAG"

          echo "ğŸ¯ EKS Cluster: $EKS_CLUSTER_NAME"
          echo "ğŸŒ AWS Region: $AWS_REGION"
          echo ""
          echo "ğŸ“‹ Final Status:"
          kubectl get deployment/kudos-frontend -o wide
          echo ""
          echo "ğŸ”— Service Details:"
          kubectl get service/kudos-frontend -o wide
          kubectl get service/kudos-backend -o wide

# ---------------------------------------------------------
# 8. Post-Deployment Validation & Notifications
# ---------------------------------------------------------
  post-deployment:
    name: "ğŸ“‹ Post-Deployment Validation"
    runs-on: ubuntu-latest
    needs: deploy-eks
    if: always()

    steps:
      - name: "ğŸ”‘ Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "âš™ï¸ Setup kubectl"
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: "ğŸ”— Update kubeconfig for EKS"
        run: |
          echo "ğŸ” Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "ğŸ¯ Looking for EKS cluster: $EKS_CLUSTER_NAME" 
          echo "ğŸŒ In region: $AWS_REGION"
          aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME

      - name: "ğŸ“Š Generate Deployment Report"
        run: |
          echo "# ğŸ“Š Deployment Report" > deployment-report.md
          echo "" >> deployment-report.md
          echo "**Environment:** ${{ github.event.inputs.environment || 'dev' }}" >> deployment-report.md
          echo "**Branch:** ${{ github.ref_name }}" >> deployment-report.md
          echo "**Image Tag:** $IMAGE_TAG" >> deployment-report.md
          echo "**Deployment Time:** $(date -u)" >> deployment-report.md
          echo "**Commit SHA:** ${{ github.sha }}" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## Application Status" >> deployment-report.md
          echo '```' >> deployment-report.md
          kubectl get deployment/kudos-frontend -o wide >> deployment-report.md
          kubectl get deployment/kudos-backend -o wide >> deployment-report.md
          echo '```' >> deployment-report.md
          echo "" >> deployment-report.md
          echo "## Pods Status" >> deployment-report.md
          echo '```' >> deployment-report.md
          kubectl get pods -l app=kudos-frontend >> deployment-report.md
          kubectl get pods -l app=kudos-backend >> deployment-report.md
          echo '```' >> deployment-report.md

      - name: "ğŸ“§ Deployment Success Notification"
        if: needs.deploy-eks.result == 'success'
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸ¯ Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "ğŸ·ï¸  Image: $IMAGE_TAG"

      - name: "ğŸš¨ Deployment Failure Notification"
        if: needs.deploy-eks.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "ğŸ” Check the logs above for details"
          kubectl get events --sort-by='.lastTimestamp' || true
